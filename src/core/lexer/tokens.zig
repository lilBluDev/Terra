const std = @import("std");

/// Compares two slices and returns whether they are equal.
pub fn eql(comptime T: type, a: T, b: T) bool {
    if (a.len != b.len) return false;
    if (a.ptr == b.ptr) return true;
    for (a, b) |a_elem, b_elem| {
        if (a_elem != b_elem) return false;
    }
    return true;
}

pub const TokenType = enum {
    EOF,
    Unknown,
    Comment,

    //Literals
    Identifier,
    StringLit,
    NumberLit,
    FloatLit,

    // Enclosing
    LeftParen, // (
    RightParen, // )
    LeftBrace, // {
    RightBrace, // }
    LeftBracket, // [
    RightBracket, // ]

    // Operators
    Plus,
    Minus,
    Star,
    Slash,
    Percent,
    Caret,
    Ampersand,
    Pipe,
    Tilde,
    Exclamation,
    Equals,
    Dot,
    Comma,
    At,
    Semicolon,
    Colon,

    // Double Operators
    PlusEquals,
    MinusEquals,
    StarEquals,
    SlashEquals,
    PercentEquals,
    CaretEquals,
    GraterThan,
    GraterThanEquals,
    LessThan,
    LessThanEquals,
    EqualsEquals,
    ExclamationEquals,
    PlusPlus,
    MinusMinus,
    PipePipe,
    AmpAmp,
    Walrus,
    Arrow,

    //Reserved Keywords
    Var,
    Const,
    Fn,
    Struct,
    Enum,
    If,
    Elif,
    Else,
    For,
    While,
    In,
    Is,
    Or,
    And,
    Not,
    Import,
    Pub,

    //Reserved Type Keywords
    TrueKeyword,
    FalseKeyword,
    NullKeyword,
};

pub const str_to_roken_type_lu = std.ComptimeStringMap(TokenType, .{
    .{ "(", TokenType.LeftParen },
    .{ ")", TokenType.RightParen },
    .{ "{", TokenType.LeftBrace },
    .{ "}", TokenType.RightBrace },
    .{ "[", TokenType.LeftBracket },
    .{ "]", TokenType.RightBracket },
    .{ "+", TokenType.Plus },
    .{ "-", TokenType.Minus },
    .{ "*", TokenType.Star },
    .{ "/", TokenType.Slash },
    .{ "%", TokenType.Percent },
    .{ "^", TokenType.Caret },
    .{ "&", TokenType.Ampersand },
    .{ "|", TokenType.Pipe },
    .{ "~", TokenType.Tilde },
    .{ "!", TokenType.Exclamation },
    .{ "=", TokenType.Equals },
    .{ ".", TokenType.Dot },
    .{ ",", TokenType.Comma },
    .{ "@", TokenType.At },
    .{ ";", TokenType.Semicolon },
    .{ ":", TokenType.Colon },
    .{ "//", TokenType.Comment },
    .{ "+=", TokenType.PlusEquals },
    .{ "-=", TokenType.MinusEquals },
    .{ "*=", TokenType.StarEquals },
    .{ "/=", TokenType.SlashEquals },
    .{ "%=", TokenType.PercentEquals },
    .{ "^=", TokenType.CaretEquals },
    .{ ">", TokenType.GraterThan },
    .{ ">=", TokenType.GraterThanEquals },
    .{ "<", TokenType.LessThan },
    .{ "<=", TokenType.LessThanEquals },
    .{ "==", TokenType.EqualsEquals },
    .{ "||", TokenType.PipePipe },
    .{ "&&", TokenType.AmpAmp },
    .{ "!=", TokenType.ExclamationEquals },
    .{ "++", TokenType.PlusPlus },
    .{ "--", TokenType.MinusMinus },
    .{ "->", TokenType.Arrow },
    .{ ":=", TokenType.Walrus },
    .{ "var", TokenType.Var },
    .{ "const", TokenType.Const },
    .{ "fn", TokenType.Fn },
    .{ "struct", TokenType.Struct },
    .{ "enum", TokenType.Enum },
    .{ "if", TokenType.If },
    .{ "elif", TokenType.Elif },
    .{ "else", TokenType.Else },
    .{ "for", TokenType.For },
    .{ "while", TokenType.While },
    .{ "in", TokenType.In },
    .{ "is", TokenType.Is },
    .{ "or", TokenType.OR },
    .{ "and", TokenType.And },
    .{ "not", TokenType.Not },
    .{ "import", TokenType.Import },
    .{ "pub", TokenType.Pub },
    .{ "true", TokenType.TrueKeyword },
    .{ "false", TokenType.FalseKeyword },
    .{ "null", TokenType.NullKeyword },
});

pub const single_operator_lu = std.ComptimeStringMap(TokenType, .{
    .{ "+", TokenType.Plus },
    .{ "-", TokenType.Minus },
    .{ "*", TokenType.Star },
    .{ "/", TokenType.Slash },
    .{ "%", TokenType.Percent },
    .{ "^", TokenType.Caret },
    .{ "&", TokenType.Ampersand },
    .{ "|", TokenType.Pipe },
    .{ "~", TokenType.Tilde },
    .{ "!", TokenType.Exclamation },
    .{ "=", TokenType.Equals },
    .{ ".", TokenType.Dot },
    .{ ",", TokenType.Comma },
    .{ "@", TokenType.At },
    .{ ";", TokenType.Semicolon },
    .{ ":", TokenType.Colon },
    .{ "(", TokenType.LeftParen },
    .{ ")", TokenType.RightParen },
    .{ "{", TokenType.LeftBrace },
    .{ "}", TokenType.RightBrace },
    .{ "[", TokenType.LeftBracket },
    .{ "]", TokenType.RightBracket },
});

pub const double_opreator_lu = std.ComptimeStringMap(TokenType, .{
    .{ "//", TokenType.Comment },
    .{ "+=", TokenType.PlusEquals },
    .{ "-=", TokenType.MinusEquals },
    .{ "*=", TokenType.StarEquals },
    .{ "/=", TokenType.SlashEquals },
    .{ "%=", TokenType.PercentEquals },
    .{ "^=", TokenType.CaretEquals },
    .{ ">", TokenType.GraterThan },
    .{ ">=", TokenType.GraterThanEquals },
    .{ "||", TokenType.PipePipe },
    .{ "&&", TokenType.AmpAmp },
    .{ "<", TokenType.LessThan },
    .{ "<=", TokenType.LessThanEquals },
    .{ "==", TokenType.EqualsEquals },
    .{ "!=", TokenType.ExclamationEquals },
    .{ "++", TokenType.PlusPlus },
    .{ "--", TokenType.MinusMinus },
    .{ ":=", TokenType.Walrus },
    .{ "->", TokenType.Arrow },
});

pub const reserved_lu = std.ComptimeStringMap(TokenType, .{
    .{ "var", TokenType.Var },
    .{ "const", TokenType.Const },
    .{ "fn", TokenType.Fn },
    .{ "struct", TokenType.Struct },
    .{ "enum", TokenType.Enum },
    .{ "if", TokenType.If },
    .{ "elif", TokenType.Elif },
    .{ "else", TokenType.Else },
    .{ "for", TokenType.For },
    .{ "while", TokenType.While },
    .{ "in", TokenType.In },
    .{ "is", TokenType.Is },
    .{ "and", TokenType.Or },
    .{ "and", TokenType.And },
    .{ "not", TokenType.Not },
    .{ "import", TokenType.Import },
    .{ "pub", TokenType.Pub },
    .{ "true", TokenType.TrueKeyword },
    .{ "false", TokenType.FalseKeyword },
    .{ "null", TokenType.NullKeyword },
});

pub fn TokenType2String(tkt: TokenType) []const u8 {
    switch (tkt) {
        .Unknown => return "Unknown",
        .Comment => return "Comment",
        .Identifier => return "Identifier",
        .StringLit => return "String",
        .NumberLit, .FloatLit => return "Number",
        .LeftParen => return "Left Peren",
        .RightParen => return "Right Peren",
        .LeftBrace => return "Left Brace",
        .RightBrace => return "Right Brace",
        .LeftBracket => return "Left Bracket",
        .RightBracket => return "Right Bracket",
        .Plus => return "Plus",
        .Minus => return "Minus",
        .Star => return "Star",
        .Slash => return "Slash",
        .Percent => return "Percent",
        .Caret => return "Caret",
        .Ampersand => return "Ampersand",
        .Pipe => return "Pipe",
        .Tilde => return "Tilde",
        .Exclamation => return "Exclamation",
        .Equals => return "Equals",
        .Dot => return "Dot",
        .Comma => return "Comma",
        .At => return "At",
        .Semicolon => return "Semicolon",
        .Colon => return "Colon",
        .PlusEquals => return "PlusEquals",
        .MinusEquals => return "MinusEquals",
        .StarEquals => return "StarEquals",
        .SlashEquals => return "SlashEquals",
        .PercentEquals => return "PercentEquals",
        .CaretEquals => return "CaretEquals",
        .GraterThan => return "GraterThan",
        .GraterThanEquals => return "GraterThanEquals",
        .LessThan => return "LessThan",
        .LessThanEquals => return "LessThanEquals",
        .EqualsEquals => return "EqualsEquals",
        .ExclamationEquals => return "ExclamationEquals",
        .PlusPlus => return "PlusPlus",
        .MinusMinus => return "MinusMinus",
        .Arrow => return "Arrow",
        .Walrus => return "Walrus",
        .Var => return "Var",
        .Const => return "Const",
        .Struct => return "Struct",
        .Enum => return "Enum",
        .Fn => return "Fn",
        .If => return "If",
        .Elif => return "Elif",
        .Else => return "Else",
        .For => return "For",
        .While => return "While",
        .In => return "In",
        .Is => return "Is",
        .And => return "And",
        .Not => return "Not",
        .Import => return "Import",
        .Pub => return "Pub",
        .TrueKeyword => return "True",
        .FalseKeyword => return "False",
        .NullKeyword => return "Null",
        .EOF => return "End OF File",

        else => |t| return @tagName(t),
    }
}

pub const Token = struct {
    token_type: TokenType,
    value: []const u8,
    loc: loc,

    pub fn is(self: Token, t: TokenType) bool {
        return self.token_type == t;
    }
};

pub const loc = struct {
    line: usize,
    column: usize,
    end_line: usize,
    end_col: usize,
};
